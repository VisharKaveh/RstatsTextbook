{
  "hash": "54d54de796671c30618ef2f2ca32a0eb",
  "result": {
    "engine": "knitr",
    "markdown": "---\nengine: knitr\nbibliography: references.bib\n---\n\n# Data w`R`angling {#sec-DataWrangling}\n\n### Chapter overview {.unnumbered}\n\nIn this chapter, you will learn how to:\n\n-   Recognise whether a dataset is in a tidy data format\n-   Check the sanity of an imported dataset\n-   Pre-process data in a reproducible way using tidyverse functions\n-   Convert character vectors representing categorical data to factors\n-   Add and replace columns in a table\n-   Transform several columns of a table at once\n-   Use {stringr} functions to manipulate text values\n-   Reshape and combine tables\n-   Save and export `R` objects in different formats\n\n## Welcome to the tidyverse! 🪐 {#sec-tidyverse}\n\nThis chapter explains how to examine, clean, and manipulate data mostly using functions from the [{tidyverse}](https://www.tidyverse.org): a collection of useful `R` packages increasingly used for all kinds of data analysis projects. Tidyverse functions are designed to work with **tidy data** (see @fig-tidydata) and, as a result, they are often easier to combine.\n\n![Tidy data illustration from the [Openscapes](https://www.openscapes.org/) blog [Tidy Data for reproducibility, efficiency, and collaboration](https://www.openscapes.org/blog/2020/10/12/tidy-data/) by @horstOpenscapesTidyData2020.](images/AHorst_tidydata.jpg){#fig-tidydata fig-alt=\"Stylized text providing an overview of Tidy Data. The top reads “Tidy data is a standard way of mapping the meaning of a dataset to its structure. - Hadley Wickham.” On the left reads “In tidy data: each variable forms a column; each observation forms a row; each cell is a single measurement.” There is an example table on the lower right with columns ‘id’, ‘name’ and ‘color’ with observations for different cats, illustrating tidy data structure.\"}\n\nLearning to manipulate data and conduct data analysis in `R` \"the tidyverse-way\" can help make your workflows more efficient.\n\n> If you ensure that your data is tidy, you'll spend less time fighting with the tools and more time working on your analysis. [@TidyMessyData]\n\n## Base `R` vs. tidyverse functions {#sec-Conflicts}\n\nNovice `R` users may find it confusing that many operations can be performed using either a base `R` function or a tidyverse one. For example, in @sec-ImportingData, we saw that both the base `R` function `read.csv()` and the tidyverse function `read_csv()` can be used to import CSV files. The functions have slightly different arguments and default values, which can be annoying, even though they are fundamentally designed to perform the same task. But don't fret over this too much: it's fine for you to use whichever function you find most convenient and intuitive and it's also absolutely fine to combine base `R` and tidyverse functions!\n\nYou will no doubt have noticed that the functions `read.csv()` and `read_csv()` have very similar but not exactly identical names. This is helpful to differentiate between the two functions. Unfortunately, some function names are found in several packages, which can lead to confusion and errors! For example, you may have noticed that when you load the tidyverse library the first time in a project, a message similar to @fig-tidyverseConflicts is printed in the Console.\n\n![Screenshot of the `R` Console after having loaded the {tidyverse} library](images/TidyverseConflicts.png){#fig-tidyverseConflicts fig-alt=\"Screenshot of R Console showing the output of the command library(tidyverse). The output lists all attached core tidyverse packages and their versions and then it lists \\\"Conflicts: tidyverse_conflicts() ── ✖ dplyr::filter() masks stats::filter() ✖ dplyr::lag()    masks stats::lag() ℹ Use the conflicted package to force all conflicts to become errors\\\"\" width=\"516\"}\n\nFirst, the error message reproduced in @fig-tidyverseConflicts confirms that loading the {tidyverse} package has led to the successful loading of a total of nine packages and that these are now ready to use. Crucially, the message also warns us about **conflicts** between some {tidyverse} packages and base `R` packages. These conflicts are due to the fact that two functions from the {dplyr} package have exactly the same name as functions from the base `R` {stats} package. The warning informs us that, by default, the {dplyr} functions will be applied.\n\nTo force `R` to use a function from a specific package, we can use the `package::function()` syntax. Hence, to force `R` to use the base `R` {stats} `filter()` function rather than the tidyverse one, we would use `stats::filter()`. On the contrary, if we want to be absolutely certain that the tidyverse one is used, we can use `dplyr::filter()`.\n\n![A galaxy of tidyverse-related hex stickers (artwork by [\\@allison_horst](https://allisonhorst.com/allison-horst)).](images/AHorst_tidyverse.png){#fig-tidyverse fig-alt=\"Hexagonal stickers flying in space. The stickers all represent tidyverse packages including stringr, tidyr, readr, tibble, and dyplr.\" width=\"300\"}\n\nIn this chapter, we will explore functions from {[dplyr](https://dplyr.tidyverse.org/)}, {[stringr](https://stringr.tidyverse.org/)}, and {[tidyr](https://tidyr.tidyverse.org/)}. The popular {[ggplot2](https://ggplot2.tidyverse.org/)} tidyverse library for data visualisation following the \"Grammar of Graphics\" approach will be introduced in [Chapter 10](@sec-DataViz). Make sure that you have loaded the tidyverse packages before proceeding with the rest of this chapter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Checking data sanity {#sec-Sanity}\n\n\n\nBefore beginning any data analysis, it is important to always check the sanity of our data. In the following, we will use tables and descriptive statistics to do this. In [Chapter 10](@sec-DataViz), we will learn how to use data visualisation to check for outliers and other issues that may affect our analyses.\n\n::: {.callout-warning collapse=\"false\"}\n### Prerequisites\n\nIn this chapter and the following chapters, all examples, tasks, and quiz questions are based on data from:\n\n> Dąbrowska, Ewa. 2019. Experience, Aptitude, and Individual Differences in Linguistic Attainment: A Comparison of Native and Nonnative Speakers. Language Learning 69(S1). 72--100. <https://doi.org/10.1111/lang.12323>.\n\nYou will only be able to reproduce the analyses and answer the quiz questions from this chapter if you have created an RProject and successfully imported the two datasets from @DabrowskaExperienceAptitudeIndividual2019 into your local `R` environment (see @fig-DataLoaded). Detailed instructions to do so can be found from @sec-RProject to @sec-ImportingDataCSV.\n\nAlternatively, you can download `Dabrowska2019.zip` from [the textbook's GitHub repository](https://github.com/elenlefoll/RstatsTextbook/raw/69d1e31be7394f2b612825f031ebffeb75886390/Dabrowska2019.zip){.uri}. To launch the project correctly, first unzip the file and then double-click on the `Dabrowska2019.Rproj` file.\n\n:::\n\nBefore we get started, make sure that both the L1 and the L2 datasets are correctly loaded by checking the structure of the `R` objects using the `str()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n\nL1.data <- read.csv(file = here(\"data\", \"L1_data.csv\"))\nstr(L1.data)\n\nL2.data <- read.csv(file = here(\"data\", \"L2_data.csv\"))\nstr(L2.data)\n```\n:::\n\n\n### Numeric variables {#sec-CheckNumeric}\n\nIn @sec-IQR, we used the `summary()` function to obtain some useful descriptive statistics on a single numeric variable, namely the range, mean, median, and interquartile range (IQR).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L1.data$GrammarR)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  58.00   71.25   76.00   74.42   79.00   80.00 \n```\n\n\n:::\n:::\n\n\nTo check the sanity of a dataset, we can use this same function on an entire data table (provided that the data is in the tidy format, see @sec-tidyverse). Thus, the command `summary(L1.data)`[^9_datawrangling-1] outputs summary statistics on all the variables of the L1 dataset - in other words, on all the columns of the data frame `L1.data`.\n\n[^9_datawrangling-1]: Note that, throughout this chapter, long code output is shortened to save space. When you run this command on your own computer, however, you will see that the output is much longer that what is reprinted in this chapter. You will likely need to scroll up in your Console window to view it all.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L1.data)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n Participant             Age           Gender           Occupation       \n Length:90          Min.   :17.00   Length:90          Length:90         \n Class :character   1st Qu.:25.00   Class :character   Class :character  \n Mode  :character   Median :32.00   Mode  :character   Mode  :character  \n                    Mean   :37.54                                        \n                    3rd Qu.:55.00                                        \n                    Max.   :65.00                                        \n  OccupGroup          OtherLgs          Education             EduYrs     \n Length:90          Length:90          Length:90          Min.   :10.00  \n Class :character   Class :character   Class :character   1st Qu.:12.00  \n Mode  :character   Mode  :character   Mode  :character   Median :13.00  \n                                                          Mean   :13.71  \n                                                          3rd Qu.:14.00  \n                                                          Max.   :21.00  \n    ReadEng1        ReadEng2        ReadEng3        ReadEng      \n Min.   :0.000   Min.   :0.000   Min.   :0.000   Min.   : 0.000  \n 1st Qu.:1.000   1st Qu.:1.000   1st Qu.:2.000   1st Qu.: 5.000  \n Median :2.000   Median :2.000   Median :2.000   Median : 7.000  \n Mean   :2.522   Mean   :2.433   Mean   :2.233   Mean   : 7.189  \n 3rd Qu.:3.000   3rd Qu.:3.000   3rd Qu.:3.000   3rd Qu.: 9.750  \n Max.   :5.000   Max.   :5.000   Max.   :4.000   Max.   :14.000  \n```\n\n\n:::\n:::\n\n\nFor the numeric variables in the dataset, the `summary()` function provides us with many useful descriptive statistics to check the sanity of the data. For example, we can check whether the minimum values include improbably low values (e.g., a five-year-old participant in a written language exam) or outright impossible ones (e.g., a minus 18-year old participant!). Equally, if we know that the maximum number of points that could be obtained in the English grammar test is 100, a maximum value of more than 100 would be highly suspicious and warrant further investigation.\n\nAs far as we can see from the output of `summary(L1.data)` above, the numeric variables in @DabrowskaExperienceAptitudeIndividual2019's L1 dataset do not appear to feature any obvious problematic values.\n\n### Categorical variables as factors {#sec-Factors}\n\nHaving examined the numeric variables, we now turn to the non-numeric, categorical ones (see @sec-Variables). For these variables, the descriptive statistics returned by `summary(L1.data)` are not as insightful. They only tell us that they each include 90 values, which corresponds to the 90 participants in the L1 dataset. As we can see from the output of the `str()` function, these categorical variables are stored in `R` as character string vectors (abbreviated in the `str()` output to \"chr\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(L1.data$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n chr [1:90] \"M\" \"M\" \"M\" \"F\" \"F\" \"F\" \"F\" \"M\" \"M\" \"F\" \"F\" \"M\" \"M\" \"F\" \"M\" \"F\" ...\n```\n\n\n:::\n:::\n\n\nCharacter string vectors are a useful `R` object type for text but, in `R`, categorical variables are best stored as factors. Factors are a more efficient way to store character values because each unique character value is stored only once. The data itself is stored as a vector of integers. Let's look at an example.\n\nFirst, we convert the categorical variable `Gender` from `L1.data` that is currently stored as a character string vector to a factor vector called `L1.Gender.fct`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.Gender.fct <- factor(L1.data$Gender)\n```\n:::\n\n\nWhen we now inspect its structure using `str()`, we can see that `L1.Gender.fct` is a factor with two levels \"F\" and \"M\". The values themselves, however, are no longer listed as \"M\" \"M\" \"M\" \"F\" \"F\"..., but rather as integers: 2 2 2 1 1 1....\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(L1.Gender.fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 2 levels \"F\",\"M\": 2 2 2 1 1 1 1 2 2 1 ...\n```\n\n\n:::\n:::\n\n\nBy default, the levels of a factor are ordered alphabetically, hence in `L1.Gender.fct`, 1 corresponds to \"F\" and 2 to \"M\".\n\nThe summary output of factor vectors are far more insightful than of character variables (and look rather like the output of the `table()` function that we used in @sec-Mode).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L1.Gender.fct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n F  M \n48 42 \n```\n\n\n:::\n:::\n\n\nThe tidyverse package [{forcats}](https://forcats.tidyverse.org/) has a lot of very useful functions to manipulate factors. They all start with `fct_`.\n\n::: column-margin\n![Hex sticker of the [{forcats}](https://forcats.tidyverse.org/) package](images/hex_forcats.png){#fig-hexdplyr width=\"100\" alt-text=\"The forcats hexagonal logo features four lazy black cats in a cardboard box.\"}\n:::\n\n::: callout-tip\n#### Quiz time! {.unnumbered}\n\n[**Q9.1**]{style=\"color:green;\"} Type `?fct_` in an `R` script or directly in the Console and then press the tab key (↹ or ⇥ on your keyboard). A list of all loaded functions that start with `fct_` should pop up. Which of these is *not* listed?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_30673\" onsubmit=\"return validate_form_30673()\" method=\"post\">\n<input type=\"radio\" name=\"answer_30673\" id=\"answer_30673_1\" value=\"fct_count\"/>\n<label>fct_count</label>\n<br/>\n<input type=\"radio\" name=\"answer_30673\" id=\"answer_30673_2\" value=\"fct_mutate\"/>\n<label>fct_mutate</label>\n<br/>\n<input type=\"radio\" name=\"answer_30673\" id=\"answer_30673_3\" value=\"fct_na_level_to_value\"/>\n<label>fct_na_level_to_value</label>\n<br/>\n<input type=\"radio\" name=\"answer_30673\" id=\"answer_30673_4\" value=\"fct_rev\"/>\n<label>fct_rev</label>\n<br/>\n<input type=\"radio\" name=\"answer_30673\" id=\"answer_30673_5\" value=\"fct_reorder\"/>\n<label>fct_reorder</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_30673\"></div>\n</form>\n<script>function validate_form_30673() {var x, text; var x = document.forms['form_30673']['answer_30673'].value;if (x == 'fct_mutate'){text = 'That’s right!';} else {text = 'No, if you call the help file of this function using <code>?</code> or <code>help()</code>, you will see that this function is part of the {forcats} package. You should have loaded it when you loaded the {tidyverse} collection of packages using <code>library(tidyverse)</code> at the beginning of the chapter.';} document.getElementById('result_30673').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1;res1 = document.getElementById('result_30673').innerText == 'That’s right!';text = res1;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n \n\n[**Q9.2**]{style=\"color:green;\"} In the factor object `L1.Gender.fct` (which we created above), the first level is \"F\" because it comes first in the alphabet. Which of these commands will make \"M\" the first level instead? Check out the help files of the following [{forcats}](https://forcats.tidyverse.org/) functions to understand what they do and try them out.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_66607\" onsubmit=\"return validate_form_66607()\" method=\"post\">\n<input type=\"checkbox\" id=\"answer_66607_1\" value=\"fct_relevel(L1.Gender.fct, &quot;M&quot;)\"/>\n<label>fct_relevel(L1.Gender.fct, \"M\")</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_66607_2\" value=\"fct_reorder(L1.Gender.fct, c(&quot;M&quot;, &quot;F&quot;))\"/>\n<label>fct_reorder(L1.Gender.fct, c(\"M\", \"F\"))</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_66607_3\" value=\"fct_rev(L1.Gender.fct)\"/>\n<label>fct_rev(L1.Gender.fct)</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_66607_4\" value=\"fct_match(L1.Gender.fct, c(&quot;M&quot;, &quot;F&quot;))\"/>\n<label>fct_match(L1.Gender.fct, c(\"M\", \"F\"))</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_66607_5\" value=\"fct_recode(L1.Gender.fct, first = &quot;M&quot;, second = &quot;F&quot;)\"/>\n<label>fct_recode(L1.Gender.fct, first = \"M\", second = \"F\")</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_66607\"></div>\n</form>\n<script>function validate_form_66607() {var text; var x1 = document.getElementById('answer_66607_1'); var x2 = document.getElementById('answer_66607_2'); var x3 = document.getElementById('answer_66607_3'); var x4 = document.getElementById('answer_66607_4'); var x5 = document.getElementById('answer_66607_5'); if (x1.checked == true&x2.checked == false&x3.checked == true&x4.checked == false&x5.checked == true){text = 'Correct, well done!';} else {text = 'No, not quite. Note that three of these commands will yield the desired outcome! Check out the functions’ descriptions in the help files, as some of these function names may be misleading.';} document.getElementById('result_66607').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!';text = res1 + res2;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_51815\" onmouseover=\"return show_hint_51815()\">😇 Hover for a hint</div>\n<div id=\"result_51815\" onmouseover=\"return show_hint_51815()\"></div>\n<script>function show_hint_51815(){var x = document.getElementById('result_51815').innerHTML; if(!x){document.getElementById('result_51815').innerHTML = 'Use the <code>?</code> function to access the help files of each function and then try the above commands out! When you print an entire factor variable in the Console, the order of the levels is displayed at the bottom of the output. If the last line of your output reads “Levels: M F”, then the operation was successful.';} else {document.getElementById('result_51815').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n:::\n\n## Pre-processing data {#sec-Preprocessing}\n\n### Using `mutate()` to add and replace columns {#sec-mutate}\n\nIn the previous section, we stored the factor representing L1 participants' gender as a separate `R` object called `L1.Gender.fct`. If, instead, we want to add this factor as an additional column to our dataset, we can use the `mutate()` function from [{dplyr}](https://dplyr.tidyverse.org/).\n\n::: column-margin\n![Hex sticker of the [{dplyr}](https://dplyr.tidyverse.org/) package](images/hex_dplyr.png){width=\"100\"}\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.data <- L1.data |> \n  mutate(Gender.fct = factor(L1.data$Gender))\n```\n:::\n\n\nThe `mutate()` function allows us to add new columns to a dataset. By default, it also keeps all the existing ones (to control which columns are retained, check the help file and read about the \".keep =\" argument).\n\n![Artwork explaining the `dplyr::mutate()` function by [\\@allison_horst](https://allisonhorst.com/allison-horst).](images/AHorst_mutate.png){#fig-mutate fig-alt=\"Cartoon of cute fuzzy monsters dressed up as different X-men characters, working together to add a new column to an existing data frame. Stylized title text reads “dplyr::mutate - add columns, keep existing.”\" width=\"465\"}\n\nWe can use the `colnames()` function to check that the new column has been correctly appended to the table. Alternatively, you can use the `View()` function to display the table in full in a new *RStudio* tab. In both cases, you should see that the new column is now the last column in the table (column number 32).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(L1.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Participant\" \"Age\"         \"Gender\"      \"Occupation\"  \"OccupGroup\" \n [6] \"OtherLgs\"    \"Education\"   \"EduYrs\"      \"ReadEng1\"    \"ReadEng2\"   \n[11] \"ReadEng3\"    \"ReadEng\"     \"Active\"      \"ObjCl\"       \"ObjRel\"     \n[16] \"Passive\"     \"Postmod\"     \"Q.has\"       \"Q.is\"        \"Locative\"   \n[21] \"SubCl\"       \"SubRel\"      \"GrammarR\"    \"Grammar\"     \"VocabR\"     \n[26] \"Vocab\"       \"CollocR\"     \"Colloc\"      \"Blocks\"      \"ART\"        \n[31] \"LgAnalysis\"  \"Gender.fct\" \n```\n\n\n:::\n:::\n\n\nWatch out: if you add a new column to a table using an existing column name, `mutate()` will overwrite the entire content of the existing column with the new values! In the following code chunk, we are therefore overwriting the character vector `Gender` with a factor vector also called `Gender`. We should only do this if we are certain that we won't need to compare the original values with the new ones!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.data <- L1.data |> \n  mutate(Gender = factor(L1.data$Gender))\n```\n:::\n\n\n### Using `across()` to transform multiple columns {#sec-across}\n\nIn addition to `Gender`, there are quite a few more character vectors in `L1.data` that represent categorical variables and that would therefore be better stored as factors. We could use `mutate()` and `factor()` to convert them one by one like we did for `Gender` above, but that would require several lines of code in which we could easily make a silly error or two. Instead, we can use a series of neat tidyverse functions to convert all character vectors to factor vectors in one go.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.data.fct <- L1.data |> \n  mutate(across(where(is.character), factor))\n```\n:::\n\n\nAbove, we use `mutate()` to convert `across()` the entire dataset all columns `where()` there are character vectors to `factor()` vectors (using the `is.character()` function to determine which columns contain character vectors).\n\n![Artwork explaining the `across()` function by [\\@allison_horst](https://allisonhorst.com/allison-horst).](images/AHorst_across.png){#fig-across fig-alt=\"A cute round fuzzy monster with fairy wings and a wand, with a party hat on reading “mean”, bouncing across the top of a data table applying the function to each column. Stylized text reads: “dplyr::across() - use within mutate() or summarize() to apply function(s) to a selection of columns!” An example shows the use within summarize: summarize(across(where(is.numeric), mean)).\"}\n\nWe can check that the correct variables have been converted by comparing the output of `summary(L1.data)` (partially printed in @sec-CheckNumeric) with the output of `summary(L1.data.fct)` (partially printed below).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L1.data.fct)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  Participant      Age        Gender          Occupation OccupGroup\n 1      : 1   Min.   :17.00   F:48   Retired       :14   C  :22    \n 100    : 1   1st Qu.:25.00   M:42   Student       :14   I  :23    \n 101    : 1   Median :32.00          Unemployed    : 4   M  :20    \n 104    : 1   Mean   :37.54          Housewife     : 3   PS :24    \n 106    : 1   3rd Qu.:55.00          Shop Assistant: 3   PS : 1    \n 107    : 1   Max.   :65.00          Teacher       : 3             \n (Other):84                          (Other)       :49             \n    OtherLgs                                  Education      EduYrs     \n French : 2   student                              : 8   Min.   :10.00  \n German : 3   A level                              : 5   1st Qu.:12.00  \n None   :84   BA                                   : 5   Median :13.00  \n Spanish: 1   GCSEs                                : 5   Mean   :13.71  \n              NVQ                                  : 4   3rd Qu.:14.00  \n              Northern Counties School Leaving Exam: 3   Max.   :21.00  \n              (Other)                              :60                  \n    ReadEng1        ReadEng2        ReadEng3        ReadEng      \n Min.   :0.000   Min.   :0.000   Min.   :0.000   Min.   : 0.000  \n 1st Qu.:1.000   1st Qu.:1.000   1st Qu.:2.000   1st Qu.: 5.000  \n Median :2.000   Median :2.000   Median :2.000   Median : 7.000  \n Mean   :2.522   Mean   :2.433   Mean   :2.233   Mean   : 7.189  \n 3rd Qu.:3.000   3rd Qu.:3.000   3rd Qu.:3.000   3rd Qu.: 9.750  \n Max.   :5.000   Max.   :5.000   Max.   :4.000   Max.   :14.000  \n                                                                 \n```\n\n\n:::\n:::\n\n\n::: callout-caution\n#### [**Task 9.1**]{style=\"color:green;\"} {.unnumbered}\n\nIn this [**task**]{style=\"color:green;\"}, you will do some data wrangling on the L2 dataset from @DabrowskaExperienceAptitudeIndividual2019.\n\n[**a.**]{style=\"color:green;\"} Which of these columns from `L2.data` represent categorical variables and therefore ought to be converted to factors?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_27795\" onsubmit=\"return validate_form_27795()\" method=\"post\">\n<input type=\"checkbox\" id=\"answer_27795_1\" value=\"UseEngC\"/>\n<label>UseEngC</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_27795_2\" value=\"OccupGroup\"/>\n<label>OccupGroup</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_27795_3\" value=\"EdNative\"/>\n<label>EdNative</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_27795_4\" value=\"NativeLg\"/>\n<label>NativeLg</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_27795_5\" value=\"Arrival\"/>\n<label>Arrival</label>\n<br/>\n<input type=\"checkbox\" id=\"answer_27795_6\" value=\"FirstExp\"/>\n<label>FirstExp</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_27795\"></div>\n</form>\n<script>function validate_form_27795() {var text; var x1 = document.getElementById('answer_27795_1'); var x2 = document.getElementById('answer_27795_2'); var x3 = document.getElementById('answer_27795_3'); var x4 = document.getElementById('answer_27795_4'); var x5 = document.getElementById('answer_27795_5'); var x6 = document.getElementById('answer_27795_6'); if (x1.checked == false&x2.checked == true&x3.checked == true&x4.checked == true&x5.checked == false&x6.checked == false){text = 'That’s right!';} else {text = 'Not quite. Three of the above are categorical variables.';} document.getElementById('result_27795').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!';text = res1 + res2 + res3;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_67582\" onclick=\"return show_hint_67582()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_67582\" onclick=\"return show_hint_67582()\"></div>\n<script>function show_hint_67582(){var x = document.getElementById('result_67582').innerHTML; if(!x){document.getElementById('result_67582').innerHTML = 'Run the <code>str(L2.data)</code> command to examine the structure of the L2 dataset.';} else {document.getElementById('result_67582').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n[**b.**]{style=\"color:green;\"} Convert all character vectors of `L2.data` to factors and save the new table as `L2.data.fct`. Use the `str()` function to check that your conversion has worked as planned. How many different factor levels are there in the categorical variable `Occupation`?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_91247\" onsubmit=\"return validate_form_91247()\" method=\"post\">\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_1\" value=\"27\"/>\n<label>27</label>\n<br/>\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_2\" value=\"4\"/>\n<label>4</label>\n<br/>\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_3\" value=\"48\"/>\n<label>48</label>\n<br/>\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_4\" value=\"67\"/>\n<label>67</label>\n<br/>\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_5\" value=\"45\"/>\n<label>45</label>\n<br/>\n<input type=\"radio\" name=\"answer_91247\" id=\"answer_91247_6\" value=\"44\"/>\n<label>44</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_91247\"></div>\n</form>\n<script>function validate_form_91247() {var x, text; var x = document.forms['form_91247']['answer_91247'].value;if (x == '48'){text = 'That’s right.';} else {text = 'No';} document.getElementById('result_91247').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.';text = res1 + res2 + res3 + res4;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"🐭 Click on the mouse to view `R` code to help you answer **c.**\"}\nL2.data.fct <- L2.data |> \n  mutate(across(where(is.character), factor))\n\nstr(L2.data.fct)\n```\n:::\n\n\n[**c.**]{style=\"color:green;\"} Use the `summary()` and `str()` functions to inspect the sanity of L2 dataset now that you have converted all the character vectors to factors. Have you noticed that there three factor levels in the `Gender` variable of the L2 dataset whereas there are only two in the L1 dataset? What is the most likely reason for this?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_34930\" onsubmit=\"return validate_form_34930()\" method=\"post\">\n<input type=\"radio\" name=\"answer_34930\" id=\"answer_34930_1\" value=\"Because these six participants identify as non-binary.\"/>\n<label>Because these six participants identify as non-binary.</label>\n<br/>\n<input type=\"radio\" name=\"answer_34930\" id=\"answer_34930_2\" value=\"Because sometimes &quot;female&quot; was recorded as lower-case &quot;f&quot; rather than upper-case &quot;F&quot;.\"/>\n<label>Because sometimes \"female\" was recorded as lower-case \"f\" rather than upper-case \"F\".</label>\n<br/>\n<input type=\"radio\" name=\"answer_34930\" id=\"answer_34930_3\" value=\"Because these six participants declined to answer the question about their gender.\"/>\n<label>Because these six participants declined to answer the question about their gender.</label>\n<br/>\n<input type=\"radio\" name=\"answer_34930\" id=\"answer_34930_4\" value=\"Because these six participants were under 18 at the time of data collection.\"/>\n<label>Because these six participants were under 18 at the time of data collection.</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_34930\"></div>\n</form>\n<script>function validate_form_34930() {var x, text; var x = document.forms['form_34930']['answer_34930'].value;if (x == 'Because sometimes \"female\" was recorded as lower-case \"f\" rather than upper-case \"F\".'){text = 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).';} else {text = 'No, it turns out that this is not the reason.';} document.getElementById('result_34930').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).';text = res1 + res2 + res3 + res4 + res5;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_64950\" onclick=\"return show_hint_64950()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_64950\" onclick=\"return show_hint_64950()\"></div>\n<script>function show_hint_64950(){var x = document.getElementById('result_64950').innerHTML; if(!x){document.getElementById('result_64950').innerHTML = 'Once you have converted all the character vectors to factors in both <code>L1.data</code> and <code>L2.data</code>, compare the outputs of <code>summary(L1.data$Gender)</code> and <code>summary(L2.data$Gender)</code>.';} else {document.getElementById('result_64950').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n:::\n\n## Data cleaning 🧼\n\nBy closely examining the data, we noticed that the values of the categorical variables were not always entered in a consistent way, which may lead to incorrect analyses. For example, in the L2 dataset, most female participants' gender is recorded as `F` except for six participants, where it is `f`. As `R` is a case-sensitive language, these two factor levels are treated as two different levels of the `Gender` variable. This means that any future analyses on the effect of `Gender` on language learning will compare participants across these three groups.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L2.data.fct$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n f  F  M \n 6 40 21 \n```\n\n\n:::\n:::\n\n\n::: callout-important\nTo ensure that our analyses are **reproducible** (see @sec-Reproducibility) from the beginning to the end, it is crucial that we document *all* of our corrections in a script. This ensures that if we need to go back on any data pre-processing decision that we made or if we need to make any additional corrections, we can do so without having to re-do our entire analyses. In addition, it means that our corrections and other data pre-processing steps are transparent and can be inspected and challenged by our peers.\n:::\n\n### Using {stringr} functions {#sec-stringR}\n\nTo convert all of the lower-case \"f\" in the `Gender` variable to upper-case \"F\", we can combine the `mutate()` with the `str_to_upper()` function. This ensures that all values in the new `Gender.corrected` column are in capital letters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data.cleaned <- L2.data.fct |> \n  mutate(Gender.corrected = str_to_upper(Gender))\n```\n:::\n\n\nWe should check that our correction has gone to plan by comparing the original `Gender` variable with the new `Gender.corrected`. To this end, we display them side by side using the `select()` function from {dplyr}.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data.cleaned |> \n  select(Gender, Gender.corrected)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  Gender Gender.corrected\n1      F                F\n2      f                F\n3      F                F\n4      F                F\n5      M                M\n6      F                F\n```\n\n\n:::\n:::\n\n\nLike `mutate()` and `select()`, `str_to_upper()` also comes from a tidyverse package[^9_datawrangling-2]. All functions that begin with `str_` come from the {stringr} package, which features lots of useful functions to manipulate character string vectors. These include:\n\n[^9_datawrangling-2]: The equivalent base `R` function is `toupper()`.\n\n::: column-margin\n![Hex sticker of the [{stringr}](https://stringr.tidyverse.org/) package](images/hex_stringr.png){#fig-hexstringr width=\"100\"}\n:::\n\n-   `str_to_upper()` converts to string upper case.\n-   `str_to_lower()` converts to string lower case.\n-   `str_to_title()` converts to string title case (i.e. only the first letter of each word is capitalised).\n-   `str_to_sentence()` converts string to sentence case (i.e. only the first letter of each sentence is capitalised).\n\nFor more useful functions to manipulate character strings, check out the {stringr} cheatsheet: <https://github.com/rstudio/cheatsheets/blob/main/strings.pdf>.\n\nNote that in the code chunk above, we did not save the output to a new `R` object. We merely printed the output in the Console. Once we have checked that our data wrangling operation went well, we can overwrite the original `Gender` variable with the cleaned version by using the original variable name as the name of the new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data.cleaned <- L2.data.fct |> \n  mutate(Gender = str_to_upper(Gender))\n```\n:::\n\n\nUsing `summary()` or `class()`, we can see that manipulating the `Gender` variable with a function from {stringr} has resulted in the factor variable being converted back to a character variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L2.data.cleaned$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Length     Class      Mode \n       67 character character \n```\n\n\n:::\n\n```{.r .cell-code}\nclass(L2.data.cleaned$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\nWe therefore need to add a line of code to reconvert it to a factor. We can do this within a single `mutate()` command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data.cleaned <- L2.data.fct |> \n  mutate(Gender = str_to_upper(Gender),\n         Gender = factor(Gender))\n\nclass(L2.data.cleaned$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\nNow the `summary()` function provides a tally of male and female participants that corresponds to the values reported in @DabrowskaExperienceAptitudeIndividual2019 [p.5].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(L2.data.cleaned$Gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n F  M \n46 21 \n```\n\n\n:::\n:::\n\n\n::: callout-caution\n#### [**Task 9.2**]{style=\"color:green;\"} {.unnumbered}\n\nThis [**task**]{style=\"color:green;\"} focuses on the `OccupGroup` variable, which is found in both the L1 and L2 datasets.\n\n`OccupGroup` is a categorical variable that groups participants' professional occupations into different categories. In the L2 dataset, there are four occupational categories.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data.fct |> \n  count(OccupGroup)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  OccupGroup  n\n1          C 10\n2          I  3\n3          M 21\n4         PS 33\n```\n\n\n:::\n:::\n\n\n@DabrowskaExperienceAptitudeIndividual2019 [p. 6] explains that these abbreviations correspond to:\n\n> **C**: Clerical positions\\\n> **I**: Occupationally inactive (i.e., unemployed, retired, or homemakers)\\\n> **M**: Manual jobs\\\n> **PS**: Professional-level jobs or studying for a degree\n\n[**a.**]{style=\"color:green;\"} Examine the `OccupGroup` variable in the L1 dataset (`L1.data`). What do you notice? Why are L1 participants grouped into five rather than four occupational categories?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_85512\" onsubmit=\"return validate_form_85512()\" method=\"post\">\n<input type=\"radio\" name=\"answer_85512\" id=\"answer_85512_1\" value=\"Because this study has more L1 participants than L2 participants.\"/>\n<label>Because this study has more L1 participants than L2 participants.</label>\n<br/>\n<input type=\"radio\" name=\"answer_85512\" id=\"answer_85512_2\" value=\"Because one L1 participant had an occupation that did not fit any of the other four categories.\"/>\n<label>Because one L1 participant had an occupation that did not fit any of the other four categories.</label>\n<br/>\n<input type=\"radio\" name=\"answer_85512\" id=\"answer_85512_3\" value=\"Because an extra space character was accidentally added after one &quot;PS&quot; value.\"/>\n<label>Because an extra space character was accidentally added after one \"PS\" value.</label>\n<br/>\n<input type=\"radio\" name=\"answer_85512\" id=\"answer_85512_4\" value=\"Because the original data file was saved in a format incompatible with R.\"/>\n<label>Because the original data file was saved in a format incompatible with R.</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_85512\"></div>\n</form>\n<script>function validate_form_85512() {var x, text; var x = document.forms['form_85512']['answer_85512'].value;if (x == 'Because an extra space character was accidentally added after one \"PS\" value.'){text = 'That’s right, well done! This <strong>trailing space</strong> needs to be removed otherwise <code>R</code> (and most other data analysis programmes) will consider this value to represent a fifth occupational category.';} else {text = 'No, that’s not the reason. Have you noticed that, in the output of the <code>summary(L1.data.fct$OccupGroup)</code> command, the last category does not appear to be right-aligned like the others? Why might that be?';} document.getElementById('result_85512').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.';text = res1 + res2 + res3 + res4 + res5 + res6;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"🐭 Click on the mouse to help you answer **a.**\"}\nsummary(L1.data.fct$OccupGroup)\n##   C   I   M  PS PS  \n##  22  23  20  24   1\n\nL1.data.fct |> \n  count(OccupGroup)\n##   OccupGroup  n\n## 1          C 22\n## 2          I 23\n## 3          M 20\n## 4         PS 24\n## 5        PS   1\n```\n:::\n\n\n \n\n[**b.**]{style=\"color:green;\"} Which {stringr} function removes trailing spaces from character strings? Find the appropriate function on the [{stringr} cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf).\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_34760\" onsubmit=\"return validate_form_34760()\" method=\"post\">\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_1\" value=\"str_trim()\"/>\n<label>str_trim()</label>\n<br/>\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_2\" value=\"str_flatten()\"/>\n<label>str_flatten()</label>\n<br/>\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_3\" value=\"str_squish()\"/>\n<label>str_squish()</label>\n<br/>\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_4\" value=\"str_extract()\"/>\n<label>str_extract()</label>\n<br/>\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_5\" value=\"str_ends()\"/>\n<label>str_ends()</label>\n<br/>\n<input type=\"radio\" name=\"answer_34760\" id=\"answer_34760_6\" value=\"str_glue()\"/>\n<label>str_glue()</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_34760\"></div>\n</form>\n<script>function validate_form_34760() {var x, text; var x = document.forms['form_34760']['answer_34760'].value;if (x == 'str_trim()'){text = 'That’s right! Now, use <code>str_trim()</code> to remove all trailing spaces in the <code>OccupGroup</code> variable. Check that you then have an L1 dataset with only four occupational categories.';} else {text = 'No, this function won’t help us for this task. You can use the <code>?</code> command to find out more about each of these functions if you’re struggling to interpret the <a href=\"https://github.com/rstudio/cheatsheets/blob/main/strings.pdf\">{stringr} cheatsheet</a>.';} document.getElementById('result_34760').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.';text = res1 + res2 + res3 + res4 + res5 + res6 + res7;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_12536\" onclick=\"return show_hint_12536()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_12536\" onclick=\"return show_hint_12536()\"></div>\n<script>function show_hint_12536(){var x = document.getElementById('result_12536').innerHTML; if(!x){document.getElementById('result_12536').innerHTML = 'The function can be found in the “Manage Lengths” section of the <a href=\"https://github.com/rstudio/cheatsheets/blob/main/strings.pdf\">{stringr} cheatsheet</a>.';} else {document.getElementById('result_12536').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show `R` code to use the function and check that it worked as expected.\"}\nL1.data.cleaned <- L1.data.fct |> \n  mutate(OccupGroup = str_trim(OccupGroup))\n\nL1.data.cleaned |> \n  count(OccupGroup)\n```\n:::\n\n\n \n\n[**c.**]{style=\"color:green;\"} Following the removal of trailing whitespaces, what percentage of L1 participants have a professional-level jobs/are studying for a degree?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_81861\" onsubmit=\"return validate_form_81861()\" method=\"post\">\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_1\" value=\"20%\"/>\n<label>20%</label>\n<br/>\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_2\" value=\"22.22%\"/>\n<label>22.22%</label>\n<br/>\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_3\" value=\"24.44%\"/>\n<label>24.44%</label>\n<br/>\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_4\" value=\"25%\"/>\n<label>25%</label>\n<br/>\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_5\" value=\"26%\"/>\n<label>26%</label>\n<br/>\n<input type=\"radio\" name=\"answer_81861\" id=\"answer_81861_6\" value=\"28%\"/>\n<label>28%</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_81861\"></div>\n</form>\n<script>function validate_form_81861() {var x, text; var x = document.forms['form_81861']['answer_81861'].value;if (x == '28%'){text = 'That’s right, well done!';} else {text = 'No, check the hint or look at the <code>R</code> code below if you’re stuck.';} document.getElementById('result_81861').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_45628\" onclick=\"return show_hint_45628()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_45628\" onclick=\"return show_hint_45628()\"></div>\n<script>function show_hint_45628(){var x = document.getElementById('result_45628').innerHTML; if(!x){document.getElementById('result_45628').innerHTML = 'We are looking for the proportion of L1 participants assigned the occupational group “PS”. You will need to use the <code>count()</code> and the <code>mutate()</code> functions to be able to answer this question.';} else {document.getElementById('result_45628').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show `R` code to answer question **c.**\"}\nL1.data.cleaned |> \n  count(OccupGroup) |> \n  mutate(percent = n / sum(n),\n         percent = percent*100, \n         percent = round(percent, digits = 2)\n         )\n```\n:::\n\n:::\n\nSo far, we have looked at rather simple data cleaning cases. Let's now turn to a slightly more complex one: In the L2 dataset, the variable `NativeLg` contains character string values that correspond to the L2 participants' native language. Using the base `R` function `unique()`, we can see that there are a total of 22 unique values in this variable. However using `sort()` to order these 22 values alphabetically, we can easily see that there are, in fact, fewer unique native languages in this dataset due to different spellings and the inconsistent use of upper-case letters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"           \"Cantonese/Hokkein\"   \"chinese\"            \n [4] \"Chinese\"             \"french\"              \"German\"             \n [7] \"greek\"               \"Italian\"             \"Lithuanian\"         \n[10] \"Lithunanina\"         \"Lituanian\"           \"Mandarin\"           \n[13] \"Mandarin Chinese\"    \"Mandarin/ Cantonese\" \"mandarin/malaysian\" \n[16] \"Mandarine Chinese\"   \"polish\"              \"Polish\"             \n[19] \"Polish/Russian\"      \"russian\"             \"Russian\"            \n[22] \"Spanish\"            \n```\n\n\n:::\n:::\n\n\nIf we convert all `NativeLg` values to title case, we can reduce the number of unique languages to 19.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"           \"Cantonese/Hokkein\"   \"Chinese\"            \n [4] \"French\"              \"German\"              \"Greek\"              \n [7] \"Italian\"             \"Lithuanian\"          \"Lithunanina\"        \n[10] \"Lituanian\"           \"Mandarin\"            \"Mandarin Chinese\"   \n[13] \"Mandarin/ Cantonese\" \"Mandarin/Malaysian\"  \"Mandarine Chinese\"  \n[16] \"Polish\"              \"Polish/Russian\"      \"Russian\"            \n[19] \"Spanish\"            \n```\n\n\n:::\n:::\n\n\nSecond, to facilitate further analyses, we may decide to only retain the first word/language from each entry as this will further reduce the number of different levels in this categorical variable. To abbreviate \"Mandarin Chinese\" to \"Mandarin\", we can use the `word()` function from the {stringr} package.\n\nBelow is an extract of the help page for the `word()` function (accessed with the command `?word`). Can you work out how to extract the first word of a character string?\n\n> |                |                 |\n> |----------------|----------------:|\n> | word {stringr} | R Documentation |\n>\n> ## Extract words from a sentence {#sec-WordHelp}\n>\n> ### Description\n>\n> Extract words from a sentence\n>\n> ### Usage\n>\n> ```         \n> word(string, start = 1L, end = start, sep = fixed(\" \"))\n> ```\n>\n> ### Arguments\n>\n> +----------------+-------------------------------------------------------------------------------------------------------------------------+\n> | `string`       | Input vector. Either a character vector, or something coercible to one.                                                 |\n> +----------------+-------------------------------------------------------------------------------------------------------------------------+\n> | `start`, `end` | Pair of integer vectors giving range of words (inclusive) to extract. If negative, counts backwards from the last word. |\n> |                |                                                                                                                         |\n> |                | The default value select the first word.                                                                                |\n> +----------------+-------------------------------------------------------------------------------------------------------------------------+\n> | `sep`          | Separator between words. Defaults to single space.                                                                      |\n> +----------------+-------------------------------------------------------------------------------------------------------------------------+\n\nThe help file tells us that \"The default value select the first word\". In our case, this means that we can simply use the `word()` function with no specified argument as this will automatically retain only the first word of every entry.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  word() |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"          \"Cantonese/Hokkein\"  \"Chinese\"           \n [4] \"French\"             \"German\"             \"Greek\"             \n [7] \"Italian\"            \"Lithuanian\"         \"Lithunanina\"       \n[10] \"Lituanian\"          \"Mandarin\"           \"Mandarin/\"         \n[13] \"Mandarin/Malaysian\" \"Mandarine\"          \"Polish\"            \n[16] \"Polish/Russian\"     \"Russian\"            \"Spanish\"           \n```\n\n\n:::\n:::\n\n\nAlternatively, we can choose to specify the \"start\" argument as a reminder of what we did and to better document our code. The output is exactly the same.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  word(start = 1) |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"          \"Cantonese/Hokkein\"  \"Chinese\"           \n [4] \"French\"             \"German\"             \"Greek\"             \n [7] \"Italian\"            \"Lithuanian\"         \"Lithunanina\"       \n[10] \"Lituanian\"          \"Mandarin\"           \"Mandarin/\"         \n[13] \"Mandarin/Malaysian\" \"Mandarine\"          \"Polish\"            \n[16] \"Polish/Russian\"     \"Russian\"            \"Spanish\"           \n```\n\n\n:::\n:::\n\n\nAs you can tell from the output above, the `word()` function uses white space to identify word boundaries. In this dataset, however, some of the participants' native languages are separated by forward slashes (`/`) rather than or in addition to spaces. The \"Usage\" section of the help file for the `word()` function (see `?word` and @sec-WordHelp) also confirms that the default word separator symbol is a space and shows us the syntax for changing the default separator. Below we change it to a forward slash.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  word(start = 1, sep = fixed(\"/\")) |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"         \"Chinese\"           \"French\"           \n [4] \"German\"            \"Greek\"             \"Italian\"          \n [7] \"Lithuanian\"        \"Lithunanina\"       \"Lituanian\"        \n[10] \"Mandarin\"          \"Mandarin Chinese\"  \"Mandarine Chinese\"\n[13] \"Polish\"            \"Russian\"           \"Spanish\"          \n```\n\n\n:::\n:::\n\n\nNow we can combine these two word extraction methods using the pipe operator (`|>`) so that \"Cantonese/Hokkein\" is abbreviated to \"Cantonese\" and \"Mandarin/ Cantonese\" to \"Mandarin\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  word(start = 1) |> # Extracts the first word before the first space\n  word(start = 1, sep = fixed(\"/\")) |> # Extracts the first word before the first forward slash\n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"   \"Chinese\"     \"French\"      \"German\"      \"Greek\"      \n [6] \"Italian\"     \"Lithuanian\"  \"Lithunanina\" \"Lituanian\"   \"Mandarin\"   \n[11] \"Mandarine\"   \"Polish\"      \"Russian\"     \"Spanish\"    \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n#### Going further: Using regular expressions (regex) 🤓\n\nMany functions of the {stringr} package involve **regular expressions** (short: **regex**). The second page of the [{stringr} cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/strings.pdf) provides a nice overview of how regular expressions can be used to manipulate character strings in `R`.\n\nUsing the `str_extract()` function together with the regex `\\\\w+`, it is possible to extract the first word of each `NativeLg` value with just one line of code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg |>\n  str_to_title() |> \n  str_extract(\"\\\\w+\") |> \n  unique() |> \n  sort()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Cantonese\"   \"Chinese\"     \"French\"      \"German\"      \"Greek\"      \n [6] \"Italian\"     \"Lithuanian\"  \"Lithunanina\" \"Lituanian\"   \"Mandarin\"   \n[11] \"Mandarine\"   \"Polish\"      \"Russian\"     \"Spanish\"    \n```\n\n\n:::\n:::\n\n\nRegular expressions provide incredibly powerful and versatile ways to work with text in all kinds of programming languages. When conducting **corpus linguistics** research, they also allow us to conduct complex corpus queries.\n\nEach programming language/software has a slightly different flavour of regex but the basic principles are the same across all languages/software and are well worth learning. To get started, I highly recommend this beautifully designed interactive regex tutorial for beginners: <https://regexlearn.com/learn/regex101>. Have fun! 🤓\n:::\n\n### Using `case_when()` {#sec-casewhen}\n\nWe have now reduced the number of levels in the `NativeLg` variable to just 14 unique languages. But we still have some typos to correct, e.g., \"Lithunanina\" and \"Lituanian\".\n\nWe can correct these on a case-by-case basis using `case_when()`. This is a very useful tidyverse function from the {dplyr} package that is easy to use once you have gotten used to its syntax. @fig-case_when illustrates the syntax with a toy example dataset about the dangerousness of dragons (`df`). In this annotated line of code in @fig-case_when, `mutate()` is used to add a new column called `danger` whose values depend on the type of dragon that we are dealing with. The first argument of `case_when()` determines that, when the dragon `type` is equal to \"kraken\", then the `danger` value is set to \"extreme\", otherwise the danger value is set to \"high\". You can see the outcome in the appended `danger` column.\n\n![Artwork explaining the `case_when()` function by [\\@allison_horst](https://allisonhorst.com/allison-horst)).](images/AHorst_case_when.png){#fig-case_when fig-alt=\"Cartoon showing a table with creature type (kraken, dragon, or cyclops) and age (baby, teen, or adult). The three creatures listed are adding a new column named “danger”, which contains the word “extreme!” if the type is “kraken”, or “high” for any other type. Stylized text reads “dplyr::case_when() - IF ELSE...but you love it? An example of code is shown: mutate(danger = case_when(type == “kraken” ~ “extreme!”, TRUE ~ “high”).\"}\n\nApplying `case_when()` to fix the typos in the `NativeLg` variable in `L2.data`, we determine that:\n\na.  if the shortened `NativeLg` value is \"Mandarine\", we replace it with \"Mandarin\", and\nb.  if the shortened `NativeLg` value corresponds to either \"Lithunanina\" or \"Lituanian\", we replace it with \"Lithuanian\".\n\nUsing `mutate()`, we save this cleaned-up version of the `NativeLg` variable as a new column in our `L2.data` table, which we call `NativeLg.cleaned`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |>\n  mutate(\n    NativeLg.cleaned = str_to_title(NativeLg) |> \n      word(start = 1) |> \n      word(start = 1, sep = fixed(\"/\")),\n    NativeLg.cleaned = case_when(\n      NativeLg.cleaned == \"Mandarine\" ~ \"Mandarin\",\n      NativeLg.cleaned %in% c(\"Lithunanina\", \"Lituanian\") ~ \"Lithuanian\",\n      TRUE ~ NativeLg.cleaned)\n    )\n```\n:::\n\n\nWhenever we do any data wrangling, it is crucial that we take the time to carefully check that we have not made any mistakes in the process. To this end, we display the original `NativeLg` and the new `NativeLg.cleaned` variables side by side using the `select()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data |> \n  select(NativeLg, NativeLg.cleaned)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n    NativeLg NativeLg.cleaned\n1 Lithuanian       Lithuanian\n2     polish           Polish\n3     Polish           Polish\n4    Italian          Italian\n5  Lituanian       Lithuanian\n6     Polish           Polish\n```\n\n\n:::\n:::\n\n\nAs you can see, only the first six rows of the table are printed above. Run the code yourself to check all the other rows.\n\n::: {.callout-note collapse=\"true\"}\n#### Using base `R` functions instead\n\nThis chapter focuses on {tidyverse} functions, however all of the above data wrangling and cleaning operations can equally be achieved using base `R` functions. For example, the `mutate()` code chunk above could be replaced by the following lines of base `R` code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data$NativeLg.cleaned.base <- gsub(\"([a-zA-Z]+).*\", \"\\\\1\", L2.data$NativeLg) # <1>\nL2.data$NativeLg.cleaned.base <- tools::toTitleCase(L2.data$NativeLg.cleaned.base) # <2>\nL2.data$NativeLg.cleaned.base[L2.data$NativeLg.cleaned.base == \"Mandarine\"] <- \"Mandarin\" # <3>\nL2.data$NativeLg.cleaned.base[L2.data$NativeLg.cleaned.base %in% c(\"Lithunanina\", \"Lituanian\")] <- \"Lithuanian\" # <4>\n```\n:::\n\n\n1.  With the first line, we extract the first string of letters before any space or slash in `NativeLg` and save this to a new variable called `NativeLg.cleaned.base`.\n\n2.  This line converts all the values of the new variable to title case using a base `R` function from the {tools} package. The {tools} package comes with `R` so you don't need to install it separately but, if you haven't loaded it earlier in your `R` session, you need to call the function with the prefix `tools::` so that `R` knows where to find the `toTitleCase()` function.\n\n3.  The third line corrects a typo with a direct replacement.\n\n4.  This line replaces two typos with a single correction.\n\nIf we now compare the variable created with the tidyverse code (`NativeLg.cleaned`) vs. the one created using base R functions only (`NativeLg.cleaned.base`), we can see that they are exactly the same.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data |> \n  select(NativeLg.cleaned, NativeLg.cleaned.base) \n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  NativeLg.cleaned NativeLg.cleaned.base\n1       Lithuanian            Lithuanian\n2           Polish                Polish\n3           Polish                Polish\n4          Italian               Italian\n5       Lithuanian            Lithuanian\n6           Polish                Polish\n```\n\n\n:::\n:::\n\n\nAn undeniable advantage of sticking to base `R` functions is that your code is more portable as it does not require the installation of any additional packages, keeping dependencies on external packages to the minimum. However, base `R` lacks the consistency of the tidyverse framework, which can make certain data transformation tasks considerably more tricky and code less readable (and therefore less transparent) to yourself and others.\n\nAs we don't need two versions of the cleaned `NativLg` variable, we will now remove the `NativeLg.cleaned.base` column from `L2.data`. To do so, we use the `select()` function combined with the `-` operator to \"unselect\" the column we no longer need.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  select(- NativeLg.cleaned.base)\n```\n:::\n\n:::\n\n::: callout-caution\n#### [**Task 9.3**]{style=\"color:green;\"}\n\nFor some analyses, it may be useful to group together participants whose native languages come from the same family of languages. For example, French, Spanish and Italian L1 speakers, may be considered as a one group of participants whose native language is a Romance language.\n\nUse `mutate()` and `case_when()` to add a new variable to `L2.data` that corresponds to the L2 participant's native language family. Call this new variable `NativeLgFamily`. Use the following language family categories:\n\n-   Baltic\n-   Chinese\n-   Germanic\n-   Hellenic\n-   Romance\n-   Slavic\n\nIf you're not sure which language family a language belongs to, look it up on Wikipedia (e.g. the Wikipedia page on the [German language](https://en.wikipedia.org/wiki/German_language) informs us in a text box at the top of the article that German is a Germanic language).\n\n[**a.**]{style=\"color:green;\"} Which language family is the *second* most represented among L2 participants' native languages in @DabrowskaExperienceAptitudeIndividual2019?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_65477\" onsubmit=\"return validate_form_65477()\" method=\"post\">\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_1\" value=\"Baltic\"/>\n<label>Baltic</label>\n<br/>\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_2\" value=\"Chinese\"/>\n<label>Chinese</label>\n<br/>\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_3\" value=\"Germanic\"/>\n<label>Germanic</label>\n<br/>\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_4\" value=\"Hellenic\"/>\n<label>Hellenic</label>\n<br/>\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_5\" value=\"Romance\"/>\n<label>Romance</label>\n<br/>\n<input type=\"radio\" name=\"answer_65477\" id=\"answer_65477_6\" value=\"Slavic\"/>\n<label>Slavic</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_65477\"></div>\n</form>\n<script>function validate_form_65477() {var x, text; var x = document.forms['form_65477']['answer_65477'].value;if (x == 'Chinese'){text = '✅ That’s right, well done!';} else {text = 'No, have you checked that you have correctly classified all participants’ native languages?';} document.getElementById('result_65477').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_96515\" onclick=\"return show_hint_96515()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_96515\" onclick=\"return show_hint_96515()\"></div>\n<script>function show_hint_96515(){var x = document.getElementById('result_96515').innerHTML; if(!x){document.getElementById('result_96515').innerHTML = 'Once you have created your new variable, use the <code>table()</code> or <code>count()</code> function to see the distribution of language families omong L2 participants.';} else {document.getElementById('result_96515').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n\n[**b.**]{style=\"color:green;\"} How many L2 participants are native speakers of a language that belongs to the family of Romance languages?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_24784\" onsubmit=\"return validate_form_24784()\" method=\"post\">\n<input type=\"text\" placeholder=\"\" name=\"answer_24784\"/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_24784\"></div>\n</form>\n<script>function validate_form_24784() {var x, text; var x = document.forms['form_24784']['answer_24784'].value;if (x == '6'|x == 'six'){text = '✅ Très bien! ¡Muy bien hecho! Ottimo!';} else {text = 'No, that’s incorrect. Check out the hint or, if you’re really stuck, the solution below.';} document.getElementById('result_24784').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_65535\" onclick=\"return show_hint_65535()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_65535\" onclick=\"return show_hint_65535()\"></div>\n<script>function show_hint_65535(){var x = document.getElementById('result_65535').innerHTML; if(!x){document.getElementById('result_65535').innerHTML = 'Use the <code>count()</code> function as explained above to obtain a tally of the number of participants in each language family.';} else {document.getElementById('result_65535').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n\n[**c.**]{style=\"color:green;\"} What percentage of L2 participants have a Slavic native language? Round your answer to the nearest percent.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_65368\" onsubmit=\"return validate_form_65368()\" method=\"post\">\n<input type=\"text\" placeholder=\"\" name=\"answer_65368\"/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_65368\"></div>\n</form>\n<script>function validate_form_65368() {var x, text; var x = document.forms['form_65368']['answer_65368'].value;if (x == '58'|x == 'fifty-eight'|x == 'fifty eight'|x == '58%'|x == '58 %'|x == '58 percent'|x == 'fifty-eight percent'|x == 'fifty eight percent'){text = '✅ Yes, nice data wrangling job!';} else {text = 'No, that’s incorrect. First check the hint and, if you’re still stuck, take a look at the solution below.';} document.getElementById('result_65368').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10, res11;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!'; res11 = document.getElementById('result_65368').innerText == '✅ Yes, nice data wrangling job!';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10 + res11;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_62323\" onclick=\"return show_hint_62323()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_62323\" onclick=\"return show_hint_62323()\"></div>\n<script>function show_hint_62323(){var x = document.getElementById('result_62323').innerHTML; if(!x){document.getElementById('result_62323').innerHTML = 'You can copy the code from the previous section to add a “percent” column. Ensure that you adjust the correct argument in the <code>round()</code> function to obtain percentages rounded off the nearest percent.';} else {document.getElementById('result_62323').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n\n[**d.**]{style=\"color:green;\"} If you check the output of `colnames(L2.data)` or `View(L2.data)`, you will see that the new variable that you created is now the last column in the table. Consult the help file of the {dplyr} function `relocate()` to work out how to place this column immediately after `NativeLg`.\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_54864\" onsubmit=\"return validate_form_54864()\" method=\"post\">\n<select name=\"answer_54864\">\n<option>L2.data &lt;- L2.data |&gt; relocate(NativeLgFamily, after = NativeLg)</option>\n<option>L2.data &lt;- L2.data |&gt; relocate(NativeLgFamily, .after = NULL)</option>\n<option>L2.data &lt;- L2.data |&gt; relocate(f, .after = NativeLg)</option>\n<option>L2.data &lt;- L2.data |&gt; relocate(NativeLgFamily, .before = NativeLg)</option>\n<option>L2.data &lt;- L2.data |&gt; relocate(NativeLgFamily, .after = NativeLg)</option>\n</select>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_54864\"></div>\n</form>\n<script>function validate_form_54864() {var x, text; var x = document.forms['form_54864']['answer_54864'].value;if (x == 'L2.data <- L2.data |> relocate(NativeLgFamily, .after = NativeLg)'){text = '✅  Nice work!';} else {text = 'No, that’s incorrect. If you’re really stuck, have a look at the solution below.';} document.getElementById('result_54864').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10, res11, res12;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!'; res11 = document.getElementById('result_65368').innerText == '✅ Yes, nice data wrangling job!'; res12 = document.getElementById('result_54864').innerText == '✅  Nice work!';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10 + res11 + res12;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n:::\n\n\n \n:::\n\n::: {.callout-note collapse=\"true\"}\n#### Click here for solutions to [**Task 9.3**]{style=\"color:green;\"}\n\nAs always, there are several solutions to solving this [**task**]{style=\"color:green;\"}. Here is one solution based on what we have covered so far in this chapter.\n\n[**a.**]{style=\"color:green;\"} Note that the following code will only work if you followed the instructions in the section above to create the `NativeLg.cleaned` variable as it relies on this variable to create the new `NativeLgFamily` variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  mutate(NativeLgFamily = case_when(\n    NativeLg.cleaned == \"Lithuanian\" ~ \"Baltic\",\n    NativeLg.cleaned %in% c(\"Cantonese\", \"Mandarin\", \"Chinese\") ~ \"Chinese\",\n    NativeLg.cleaned == \"German\" ~ \"Germanic\",\n    NativeLg.cleaned == \"Greek\" ~ \"Hellenic\",\n    NativeLg.cleaned %in% c(\"French\", \"Italian\", \"Spanish\") ~ \"Romance\",\n    NativeLg.cleaned %in% c(\"Polish\", \"Russian\") ~ \"Slavic\"))\n```\n:::\n\n\nAs always, it is important to check that things have gone to plan.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data |> \n  select(NativeLg.cleaned, NativeLgFamily)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  NativeLg.cleaned NativeLgFamily\n1       Lithuanian         Baltic\n2           Polish         Slavic\n3           Polish         Slavic\n4          Italian        Romance\n5       Lithuanian         Baltic\n6           Polish         Slavic\n```\n\n\n:::\n:::\n\n\n[**b.**]{style=\"color:green;\"} We can display the distribution of language families using either the base `R` `table()` function or the {tidyverse} `count()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(L2.data$NativeLgFamily)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  Baltic  Chinese Germanic Hellenic  Romance   Slavic \n       5       15        1        1        6       39 \n```\n\n\n:::\n\n```{.r .cell-code}\nL2.data |> \n  count(NativeLgFamily)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  NativeLgFamily  n\n1         Baltic  5\n2        Chinese 15\n3       Germanic  1\n4       Hellenic  1\n5        Romance  6\n6         Slavic 39\n```\n\n\n:::\n:::\n\n\n[**c.**]{style=\"color:green;\"} We can add a column to show the distribution in percentages by adding a new \"percent\" column to the `count()` table using `mutate()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data |> # <1>\n  count(NativeLgFamily) |> # <2>\n  mutate(percent = n / sum(n), # <3>\n         percent = percent*100, # <4>\n         percent = round(percent, digits = 0) # <5>\n         ) |> \n  arrange(desc(n)) # <6>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  NativeLgFamily  n percent\n1         Slavic 39      58\n2        Chinese 15      22\n3        Romance  6       9\n4         Baltic  5       7\n5       Germanic  1       1\n6       Hellenic  1       1\n```\n\n\n:::\n:::\n\n\n1.  We start with the dataset that contains the new `NativeLgFamily` variable.\n2.  We pipe it into the `count()` function. As shown above, this function produces a frequency table with counts stored in the variable `n`.\n3.  We divide the number of participant with each native language (`n`) by the total number of participants (`sum(n)`). We obtain proportions ranging from 0 to 1.\n4.  We multiply these by 100 to get percentages.\n5.  We round the percentages to two decimal places.\n6.  We reorder the table so that the most represented group is at the top. To do so, we pipe our table into the `dplyr::arrange()`. By default, `arrange()` orders values in ascending order (from smallest to largest); hence, we add the `desc()` function to sort the table in descending order of frequency.\n\n🪐 Note that this a {tidyverse} approach to working out percentages, see @sec-Mode for a base `R` approach.\n\n[**d.**]{style=\"color:green;\"} At the time of writing, the help file of the `relocate()` function still featured examples using the {magrittr} pipe (`%>%`) rather than the native `R` pipe (`|>`) (see @sec-Piping), but the syntax remains the same. The first argument is the data which we are piping into the function, the second argument is the column that we want to move. Then, we need to specify where to with either the \".after\" or the \".before\" argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  relocate(NativeLgFamily, .after = NativeLg)\n```\n:::\n\n\n![Artwork explaining the `dplyr::relocate()` function by [\\@allison_horst](https://allisonhorst.com/allison-horst).](images/AHorst_relocate.png){#fig-relocate fig-alt=\"Cartoon of fuzzy monsters moving columns around in fork lifts, while one supervises. Stylized text reads “dplyr::relocate() - move columns around! Default: move to FRONT , or move to .before or .after a specified column.”\"}\n\nNote that the help file specifies that both \".after\" and \".before\" begin with a dot. If you leave the dot out, the function will not work as expected! Can you see what's happened here?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data |> \n  relocate(NativeLgFamily, after = NativeLg) |> \n  str()\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t67 obs. of  6 variables:\n $ NativeLgFamily: chr  \"Baltic\" \"Slavic\" \"Slavic\" \"Romance\" ...\n $ after         : chr  \"Lithuanian\" \"polish\" \"Polish\" \"Italian\" ...\n $ Participant   : int  220 244 46 221 222 230 247 237 243 213 ...\n $ Gender        : chr  \"F\" \"f\" \"F\" \"F\" ...\n $ Occupation    : chr  \"Student\" \"student\" \"Cleaner\" \"Student\" ...\n $ OccupGroup    : chr  \"PS\" \"PS\" \"M\" \"PS\" ...\n```\n\n\n:::\n:::\n\n\nThe `relocate()` function has moved `NativeLgFamily` to the first column (the function's default position) and has also moved `NativeLg` to the second position, but it has renamed the column `after`.\n\nThis is a reminder to *always* check whether your data wrangling operations have gone as planned. Just because you didn't get an error message doesn't mean that your code did what you wanted! ⚠️\n:::\n\n## Combining datasets {#sec-CombiningDatasets}\n\nSo far, we have analysed the L1 and L2 datasets individually. In the following chapters, however, we will conduct comparative analyses, comparing the performance of the L1 and L2 participants in the various language-related tests conduced as part of @DabrowskaExperienceAptitudeIndividual2019. To this end, we need to create a combined table that includes the data of all participants from @DabrowskaExperienceAptitudeIndividual2019.\n\nRemember that both tables, `L1.data` and `L2.data`, are in a tidy data format. This means that:\n\n-   each row represents an observation (i.e., here, a participant),\n-   each cell represents a measurement, and\n-   each variable forms a column.\n\nTo combine the two datasets, therefore, we need to combine the rows of the two tables. However, we cannot simply add the rows of the `L2.data` table to the bottom of `L1.data` table because, as shown below, the two tables do not have the same number of columns and the shared columns are not in the same position! We therefore need to ensure that, when the two datasets are combined, the shared columns are aligned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(L1.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Participant\" \"Age\"         \"Gender\"      \"Occupation\"  \"OccupGroup\" \n [6] \"OtherLgs\"    \"Education\"   \"EduYrs\"      \"ReadEng1\"    \"ReadEng2\"   \n[11] \"ReadEng3\"    \"ReadEng\"     \"Active\"      \"ObjCl\"       \"ObjRel\"     \n[16] \"Passive\"     \"Postmod\"     \"Q.has\"       \"Q.is\"        \"Locative\"   \n[21] \"SubCl\"       \"SubRel\"      \"GrammarR\"    \"Grammar\"     \"VocabR\"     \n[26] \"Vocab\"       \"CollocR\"     \"Colloc\"      \"Blocks\"      \"ART\"        \n[31] \"LgAnalysis\"  \"Gender.fct\" \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(L2.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Participant\"      \"Gender\"           \"Occupation\"       \"OccupGroup\"      \n [5] \"NativeLg\"         \"NativeLgFamily\"   \"OtherLgs\"         \"EdNative\"        \n [9] \"EdUK\"             \"Age\"              \"EduYrsNat\"        \"EduYrsEng\"       \n[13] \"EduTotal\"         \"FirstExp\"         \"Arrival\"          \"LoR\"             \n[17] \"EngWork\"          \"EngPrivate\"       \"ReadEng1\"         \"ReadOth1\"        \n[21] \"ReadEng2\"         \"ReadOth2\"         \"ReadEng3\"         \"ReadOth3\"        \n[25] \"ReadEng\"          \"ReadOth\"          \"Active\"           \"ObjCl\"           \n[29] \"ObjRel\"           \"Passive\"          \"Postmod\"          \"Q.has\"           \n[33] \"Q.is\"             \"Locative\"         \"SubCl\"            \"SubRel\"          \n[37] \"GrammarR\"         \"Grammar\"          \"VocabR\"           \"Vocab\"           \n[41] \"CollocR\"          \"Colloc\"           \"Blocks\"           \"ART\"             \n[45] \"LgAnalysis\"       \"UseEngC\"          \"NativeLg.cleaned\"\n```\n\n\n:::\n:::\n\n\nNote, also, that participants' total number of years in education is stored in the `EduYrs` column in `L1.data`, whereas the corresponding column in `L2.data` is called `EduTotal`. Hence, we first use the {dplyr} function `rename()` to rename `EduYrs` in `L1.data` as `EduTotal` before we merge the two tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.data <- L1.data |> \n  rename(EduTotal = EduYrs)\n```\n:::\n\n\nThe {dplyr} package boasts an array of useful functions to combine tables (see @fig-dplyrcheatsheet). For our purposes, `bind_rows()` appears to be the perfect function.[^9_datawrangling-3]\n\n[^9_datawrangling-3]: We could also use the `full_join()` function since we want to retain all rows and all columns from both datasets.\n\n![Extract of the [data transformation with {dplyr} cheatsheet](https://rstudio.github.io/cheatsheets/data-transformation.pdf) (CC BY SA Posit Software, PBC)](images/dplyr_cheatsheet_extract.png){#fig-dplyrcheatsheet fig-alt=\"Extract from dplyr cheatsheet showing all the \\\"join\\\" functions. Screenreader friendly version can be found here: https://rstudio.github.io/cheatsheets/html/data-transformation.html\" out-width=\"80%\"}\n\nHowever, when we try to combine `L1.data` and `L2.data` using `bind_rows()`, we get an error message... 😢 Does this error remind you of Q10 from @sec-DataTypes by any chance?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data <- bind_rows(L1.data, L2.data)\n```\n:::\n\n\n```         \nError in `bind_rows()`:\n! Can't combine `..1$Participant` <character> and `..2$Participant` <integer>.\n```\n\nWhat this error message tells us is that the `bind_rows()` function cannot combine the two `Participant` columns because in `L1.data` it is a string character vector, whereas in `L2.data` it is an integer vector. However, to avoid data loss, `bind_rows()` can only match columns of the same data type!\n\nWe must therefore first convert the `Participant` variable in `L2.data` to a character vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  mutate(Participant = as.character(Participant))\n```\n:::\n\n\nNow, we can combine the two data frames using `bind_rows()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data <- bind_rows(L1.data, L2.data)\n```\n:::\n\n\nThe problem is that now that we have merged our two datasets into one, it's not obvious which rows correspond to L1 participants and which to L2 participants! There are various ways to solve this, but here's a simple **three-step solution** that relies exclusively on functions that you are already familiar with.\n\n**Step 1:** We add a new column to `L1.data` called `Group` and fill this column with the value \"L1\" for all rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL1.data <- L1.data |> \n  mutate(Group = \"L1\")\n```\n:::\n\n\n**Step 2:** We add a new column to `L2.data` also called `Group` and fill this column with the value \"L2\" for all rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  mutate(Group = \"L2\")\n```\n:::\n\n\n**Step 3:** We use `bind_rows()` as above to combine the two datasets that now both include the extra `Group` column.[^9_datawrangling-4]\n\n[^9_datawrangling-4]: Alternatively, you may have gathered from the cheatsheet (@fig-dplyrcheatsheet) that the `bind_rows()` function has an optional \".id\" argument that can be used to create an additional column to disambiguate between the two combined datasets. In this case, we do not need to add a `Group` column to both datasets prior to combining them.\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    combined.data <- bind_rows(L1 = L1.data, \n                               L2 = L2.data, \n                               .id = \"Group\")\n    ```\n    :::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data <- bind_rows(L1.data, L2.data)\n```\n:::\n\n\n**Verification step:** The `combined.data` table now includes the column `Group`, which we can use to easily identify the observations that belong to L1 and L2 participants. As expected, our combined dataset includes 90 participants from the L1 group and 67 from the L2 group:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data |> \n  count(Group)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Group  n\n1    L1 90\n2    L2 67\n```\n\n\n:::\n:::\n\n\nOur combined dataset contains all the columns that appear in either `L1.data` or `L2.data`. Check that this is the case by examining the structure of the new dataset with `str(combined.data)`.\n\nYou will have noticed that, in some columns, there are lots of `NA` (\"Not Available\") values. These represent **missing data**. `R` has inserted these `NA` values in the columns that only appear in one of the two datasets. For example, the L1 dataset does not include an `Arrival` variable (indicating the age when participants first arrived in an English-speaking country), presumably because they were all *born* in an English-speaking country! We only have this information for the L2 participants and this explains the 90 `NA` values in the `Arrival` column of the combined dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data$Arrival\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA 17 18 19 19 19 19 20 22 22 23\n[101] 24 25 26 26 28 28 30 44 45 49 17 23 23 24 19 22 23 26 16 18 24 24 25 29 30\n[126] 32 33 22 25 30 44 27 18 20 21 33 38 47 16 19 20 24 25 28 33 20 22 25 28 26\n[151] 26 16 24 32 20 16 20\n```\n\n\n:::\n:::\n\n\nWe can also check this by cross-tabulating the `Group` and the `Arrival` variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data |> \n  count(Group, Arrival)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  Group Arrival  n\n1    L1      NA 90\n2    L2      16  4\n3    L2      17  2\n4    L2      18  3\n5    L2      19  6\n6    L2      20  6\n```\n\n\n:::\n:::\n\n\nRun `View(combined.data)` to inspect the combined dataset and check in which other columns there are `NA` values.\n\n:::: {.callout-note collapse=\"true\"}\n#### What if my data is not yet in tidy format? 🤨\n\nCombining the two datasets from @DabrowskaExperienceAptitudeIndividual2019 was relatively easy because the data was already in tidy format. But, fear not: if you need to first convert your data to tidy format, the [{tidyr}](https://tidyr.tidyverse.org/) package has got you covered! 😎\n\nThe `pivot_longer()` and `pivot_wider()` functions allow you to easily convert tables from \"long\" to \"wide\" format and vice versa (see @fig-tidyrcheatsheet).\n\n![Extract of the [data tidying with tidyr cheatsheet](https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf) (CC BY SA Posit Software, PBC)](images/tidyr_cheatsheet_extract.png){#fig-tidyrcheatsheet fig-alt=\"pivot_longer(data, cols, names_to = \\\"name\\\", values_to = \\\"value\\\", values_drop_na = FALSE) \\\"Lengthen\\\" data by collapsing several columns into two. Column names move to a new names_to column and values to a new values_to column. pivot_longer(table4a, cols = 2:3, names_to =\\\"year\\\", values_to = \\\"cases\\\") pivot_wider(data, names_from = \\\"name\\\", values_from = \\\"value\\\") The inverse of pivot_longer(). \\\"Widen\\\" data by expanding two columns into several. One column provides the new column names, the other the values. pivot_wider(table2, names_from = type, values_from = count)\" out-width=\"60%\"}\n\n::: column-margin\n![Hex sticker of the [{tidyr}](https://tidyr.tidyverse.org/) package](images/hex_tidyr.png){#fig-tidyr width=\"100\"}\n:::\n\nRemember to carefully check the output of any data manipulation that you do *before* moving on to doing any analyses! To this end, the `View()` function is particularly helpful.\n::::\n\n::: callout-important\n### Using AI tools for coding ⚠️\n\nNote that older textbooks/tutorials, and especially AI tools such as ChatGPT that have been trained on older web data, will frequently suggest **superseded** (i.e. outdated) functions for data manipulation such as `spread()`, `gather()`, `select_all()`, and `mutate_if()`. If you use superseded functions, your code will still work, but `R` will print a warning in the Console and usually suggest a modern alternative.\n\nAI tools may also suggest using functions that are **deprecated**. As with superseded functions, you will get a warning message with a recommended alternative. In this case, however, you must follow the advice of the warning, as writing new code with deprecated functions is really asking for trouble! Deprecated functions are scheduled for removal, which means that your code will eventually no longer run on up-to-date `R` versions.\n\n![The four main stages of the lifecycle of `R` packages, functions, function arguments: **experimental** developments can become **stable** and stable can eventually become **deprecated** or **superseded** (image by Henry and Wickham 2023 for Posit Software, PBC, <https://lifecycle.r-lib.org/articles/stages.html>).](images/lifecycle.svg){#fig-lifecycle}\n\nIn sum, to ensure the future compatibility of your code, do not ignore warnings about deprecated functions and, in general, *never ever* blindly trust the output of AI tools!\n:::\n\n## A pre-processing pipeline {#sec-filter}\n\nSo far in this chapter, we have learnt how to pre-process data for future statistical analyses and data visualisation. In the process, we have learnt about lots of different functions, mostly from the tidyverse environment (see @sec-tidyverse 🪐). Now it's time to put everything together and save our pre-processed combined dataset for future use.\n\nBut, first, let's recap all of the data wrangling operations that we performed in this chapter and combine them into one code chunk. Before running this code, we first reload the original data from @DabrowskaExperienceAptitudeIndividual2019 to overwrite any changes that were made during this chapter. This will ensure that we all have exactly the same version of the dataset for the following chapters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\n\nL1.data <- read.csv(file = here(\"data\", \"L1_data.csv\"))\nL2.data <- read.csv(file = here(\"data\", \"L2_data.csv\"))\n```\n:::\n\n\nThen, run the following lines of code to create a new `R` object called `combined.data` that contains the wrangled data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nL2.data <- L2.data |> \n  mutate(Participant = as.character(Participant)) |> \n  mutate(Group = \"L2\")  \n\nL1.data <- L1.data |> \n  mutate(Group = \"L1\") |> \n  rename(EduTotal = EduYrs)\n\ncombined.data <- bind_rows(L1.data, L2.data) |>\n  mutate(across(where(is.character), str_to_title)) |>\n  mutate(across(where(is.character), str_trim)) |>\n  mutate(OccupGroup = str_to_upper(OccupGroup)) |> \n  mutate(\n    NativeLg = word(NativeLg, start = 1),\n    NativeLg = word(NativeLg, start = 1, sep = fixed(\"/\")),\n    NativeLg = case_when(\n      NativeLg == \"Mandarine\" ~ \"Mandarin\",\n      NativeLg %in% c(\"Lithunanina\", \"Lithunanina\", \"Lituanian\") ~ \"Lithuanian\",\n      TRUE ~ NativeLg)) |> \n  mutate(NativeLgFamily = case_when(\n    NativeLg == \"Lithuanian\" ~ \"Baltic\",\n    NativeLg %in% c(\"Cantonese\", \"Mandarin\", \"Chinese\") ~ \"Chinese\",\n    NativeLg == \"German\" ~ \"Germanic\",\n    NativeLg == \"Greek\" ~ \"Hellenic\",\n    NativeLg %in% c(\"French\", \"Italian\", \"Spanish\") ~ \"Romance\",\n    NativeLg %in% c(\"Polish\", \"Russian\") ~ \"Slavic\")) |> \n  mutate(across(where(is.character), factor))\n```\n:::\n\n\nDon't forgot to check the result by examining the output of `View(combined.data)` and `str(combined.data)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(combined.data)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  Participant       Age        Gender             Occupation OccupGroup\n 1      :  1   Min.   :17.00   F:94   Student          :27   C :32     \n 100    :  1   1st Qu.:25.00   M:63   Retired          :15   I :26     \n 101    :  1   Median :31.00          Product Operative: 5   M :41     \n 104    :  1   Mean   :35.48          Teacher          : 5   PS:58     \n 106    :  1   3rd Qu.:42.00          Cleaner          : 4             \n 107    :  1   Max.   :65.00          Unemployed       : 4             \n (Other):151                          (Other)          :97             \n              OtherLgs    Education     EduTotal        ReadEng1    \n None             :98   Student: 8   Min.   : 8.50   Min.   :0.000  \n No               :11   A Level: 5   1st Qu.:13.00   1st Qu.:1.000  \n English          : 8   Ba     : 5   Median :14.00   Median :3.000  \n German           : 6   Gcses  : 5   Mean   :14.62   Mean   :2.599  \n English At School: 3   Nvq    : 4   3rd Qu.:17.00   3rd Qu.:4.000  \n English, German  : 2   (Other):63   Max.   :24.00   Max.   :5.000  \n (Other)          :29   NA's   :67                                  \n    ReadEng2        ReadEng3        ReadEng      \n Min.   :0.000   Min.   :0.000   Min.   : 0.000  \n 1st Qu.:1.000   1st Qu.:1.000   1st Qu.: 5.000  \n Median :2.000   Median :2.000   Median : 7.000  \n Mean   :2.465   Mean   :2.019   Mean   : 7.083  \n 3rd Qu.:3.000   3rd Qu.:3.000   3rd Qu.:10.000  \n Max.   :5.000   Max.   :4.000   Max.   :14.000  \n                                                 \n```\n\n\n:::\n:::\n\n\n::: callout-tip\n#### Quiz time! {.unnumbered}\n\n[**Q9.3**]{style=\"color:green;\"} The following operations describe the steps performed by the data wrangling code chunk above. In which order are the operations performed?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_33975\" onsubmit=\"return validate_form_33975()\" method=\"post\">\n<table data-quarto-disable-processing=\"true\">\n<tbody id=\"task_33975\">\n<tr>\n<td id=\"answer_33975_5\" style=\"padding:5px; border:1px solid #ccc;\">Convert the values of all character variables to title case.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_3\" style=\"padding:5px; border:1px solid #ccc;\">Change the name of one variable</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_8\" style=\"padding:5px; border:1px solid #ccc;\">Shorten and correct typos in the values of one variable.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_2\" style=\"padding:5px; border:1px solid #ccc;\">Add two new variables that each have all the same values.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_4\" style=\"padding:5px; border:1px solid #ccc;\">Merge data from the two datasets into one.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_9\" style=\"padding:5px; border:1px solid #ccc;\">Add a new variable based on another variable.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_10\" style=\"padding:5px; border:1px solid #ccc;\">Convert all character string vectors to factors.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_6\" style=\"padding:5px; border:1px solid #ccc;\">Remove whitespace at the start and end of all values in all character variables.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_1\" style=\"padding:5px; border:1px solid #ccc;\">Convert one variable to a character variable.</td>\n</tr>\n<tr>\n<td style=\"padding:5px\">\n<button type=\"button\" onclick=\"swapElementsV(this);\">⇅</button>\n</td>\n</tr>\n<tr>\n<td id=\"answer_33975_7\" style=\"padding:5px; border:1px solid #ccc;\">Convert all the values of one variable to upper case.</td>\n</tr>\n</tbody>\n</table>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_33975\"></div>\n</form>\n<script>function validate_form_33975() {var text;var ch = document.getElementById('task_33975').children; if(ch[0].children[0].id == 'answer_33975_1'&ch[2].children[0].id == 'answer_33975_2'&ch[4].children[0].id == 'answer_33975_3'&ch[6].children[0].id == 'answer_33975_4'&ch[8].children[0].id == 'answer_33975_5'&ch[10].children[0].id == 'answer_33975_6'&ch[12].children[0].id == 'answer_33975_7'&ch[14].children[0].id == 'answer_33975_8'&ch[16].children[0].id == 'answer_33975_9'&ch[18].children[0].id == 'answer_33975_10'){text = 'Perfect! 🎉';} else {text = 'No, not quite.';} document.getElementById('result_33975').innerHTML = text; evaluate_final_score(); return false;}function swapElementsV(element) {const parent = element.parentNode.parentNode; const afterNode = parent.nextElementSibling; const beforeNode = parent.previousElementSibling; parent.insertAdjacentElement('beforebegin', afterNode); parent.insertAdjacentElement('afterend', beforeNode);}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10, res11, res12, res13;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!'; res11 = document.getElementById('result_65368').innerText == '✅ Yes, nice data wrangling job!'; res12 = document.getElementById('result_54864').innerText == '✅  Nice work!'; res13 = document.getElementById('result_33975').innerText == 'Perfect! 🎉';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10 + res11 + res12 + res13;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_6794\" onclick=\"return show_hint_6794()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_6794\" onclick=\"return show_hint_6794()\"></div>\n<script>function show_hint_6794(){var x = document.getElementById('result_6794').innerHTML; if(!x){document.getElementById('result_6794').innerHTML = 'Use the up and down arrows to swap the order of any two labels in the list.The first three operations are:<ol><li>Convert one variable to a character variable.</li><li>Add two new variables that each have all the same values.</li><li>Change the name of one variable.</li></ol>';} else {document.getElementById('result_6794').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n\n[**Q9.4**]{style=\"color:green;\"} In the combined dataset, how many participants have a clerical occupation?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_43827\" onsubmit=\"return validate_form_43827()\" method=\"post\">\n<input type=\"text\" placeholder=\"\" name=\"answer_43827\"/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_43827\"></div>\n</form>\n<script>function validate_form_43827() {var x, text; var x = document.forms['form_43827']['answer_43827'].value;if (x == '32'|x == 'thirty-two'|x == 'thirty two'){text = '✅';} else {text = '❌';} document.getElementById('result_43827').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10, res11, res12, res13, res14;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!'; res11 = document.getElementById('result_65368').innerText == '✅ Yes, nice data wrangling job!'; res12 = document.getElementById('result_54864').innerText == '✅  Nice work!'; res13 = document.getElementById('result_33975').innerText == 'Perfect! 🎉'; res14 = document.getElementById('result_43827').innerText == '✅';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10 + res11 + res12 + res13 + res14;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_84132\" onclick=\"return show_hint_84132()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_84132\" onclick=\"return show_hint_84132()\"></div>\n<script>function show_hint_84132(){var x = document.getElementById('result_84132').innerHTML; if(!x){document.getElementById('result_84132').innerHTML = 'Have you tried using the <code>summary()</code> function to look into the <code>OccupGroup</code> variable of <code>combined.data</code>?';} else {document.getElementById('result_84132').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n\n \n\n[**Q9.5**]{style=\"color:green;\"} Of the participants who have a clerical occupation, how many were over 50 years old at the time of the data collection?\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<form name=\"form_10187\" onsubmit=\"return validate_form_10187()\" method=\"post\">\n<input type=\"radio\" name=\"answer_10187\" id=\"answer_10187_1\" value=\"none\"/>\n<label>none</label>\n<br/>\n<input type=\"radio\" name=\"answer_10187\" id=\"answer_10187_2\" value=\"1\"/>\n<label>1</label>\n<br/>\n<input type=\"radio\" name=\"answer_10187\" id=\"answer_10187_3\" value=\"2\"/>\n<label>2</label>\n<br/>\n<input type=\"radio\" name=\"answer_10187\" id=\"answer_10187_4\" value=\"6\"/>\n<label>6</label>\n<br/>\n<input type=\"radio\" name=\"answer_10187\" id=\"answer_10187_5\" value=\"all of them\"/>\n<label>all of them</label>\n<br/>\n<input type=\"submit\" value=\"Check answer\"/>\n<div id=\"result_10187\"></div>\n</form>\n<script>function validate_form_10187() {var x, text; var x = document.forms['form_10187']['answer_10187'].value;if (x == '6'){text = 'That’s right! Check the solution below to see different ways to find the answer to this question. 😎';} else {text = 'That’s not the correct answer. Check the hint below.';} document.getElementById('result_10187').innerHTML = text; evaluate_final_score(); return false;}function evaluate_final_score(){\n         element = document.getElementById('checkdown_final_score');\n         if(element === null){return false;} else {var element, text, res1, res2, res3, res4, res5, res6, res7, res8, res9, res10, res11, res12, res13, res14, res15;res1 = document.getElementById('result_30673').innerText == 'That’s right!'; res2 = document.getElementById('result_66607').innerText == 'Correct, well done!'; res3 = document.getElementById('result_27795').innerText == 'That’s right!'; res4 = document.getElementById('result_91247').innerText == 'That’s right.'; res5 = document.getElementById('result_34930').innerText == 'Your intuition is correct (and this is confirmed by the author in the description of the L2 participants in the published paper).'; res6 = document.getElementById('result_85512').innerText == 'That’s right, well done! This trailing space needs to be removed otherwise R (and most other data analysis programmes) will consider this value to represent a fifth occupational category.'; res7 = document.getElementById('result_34760').innerText == 'That’s right! Now, use str_trim() to remove all trailing spaces in the OccupGroup variable. Check that you then have an L1 dataset with only four occupational categories.'; res8 = document.getElementById('result_81861').innerText == 'That’s right, well done!'; res9 = document.getElementById('result_65477').innerText == '✅ That’s right, well done!'; res10 = document.getElementById('result_24784').innerText == '✅ Très bien! ¡Muy bien hecho! Ottimo!'; res11 = document.getElementById('result_65368').innerText == '✅ Yes, nice data wrangling job!'; res12 = document.getElementById('result_54864').innerText == '✅  Nice work!'; res13 = document.getElementById('result_33975').innerText == 'Perfect! 🎉'; res14 = document.getElementById('result_43827').innerText == '✅'; res15 = document.getElementById('result_10187').innerText == 'That’s right! Check the solution below to see different ways to find the answer to this question. 😎';text = res1 + res2 + res3 + res4 + res5 + res6 + res7 + res8 + res9 + res10 + res11 + res12 + res13 + res14 + res15;element.innerHTML = text;\n         return false;\n         }}</script>\n```\n\n:::\n\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hint_97970\" onclick=\"return show_hint_97970()\">🐭 Click on the mouse for a hint.</div>\n<div id=\"result_97970\" onclick=\"return show_hint_97970()\"></div>\n<script>function show_hint_97970(){var x = document.getElementById('result_97970').innerHTML; if(!x){document.getElementById('result_97970').innerHTML = 'One way to answer find the answer to this question is to cross-tabulate the <code>Age</code> and <code>OccupGroup</code> variables of <code>combined.data</code> using the count() function and then add up the numbers in your head. Check the solution below if you’re stuck.';} else {document.getElementById('result_97970').innerHTML = '';}}</script>\n```\n\n:::\n:::\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n#### Click here to see the `R` code necessary to answer [**Q9.5**]{style=\"color:green;\"}\n\nThere are various ways to find the answer to Q5. Sticking to a function that we have looked at so far, you could cross-tabulate `Age` and `OccupGroup` using the `count()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data |> \n  count(OccupGroup, Age)\n```\n:::\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   OccupGroup Age n\n1           C  20 1\n2           C  25 6\n3           C  27 2\n4           C  28 3\n5           C  29 4\n6           C  30 3\n7           C  32 3\n8           C  37 1\n9           C  38 1\n10          C  39 1\n11          C  41 1\n12          C  51 2\n13          C  52 1\n14          C  53 1\n15          C  57 1\n16          C  60 1\n```\n\n\n:::\n:::\n\n\nAnd then add up the frequencies listed in the rows that correspond to participants with clerical jobs who are 50.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 + 1 + 1 + 1 +1 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\nBut, of course, this is method is rather error-prone! Instead, we can use `dplyr::filter()` (see @fig-filter) to filter the combined dataset according to our two criteria of interest and then count the number of rows (i.e., participants) remaining in the dataset once the filter has been applied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined.data |>\n  filter(OccupGroup == \"C\" & Age > 50) |> \n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n![Artwork explaining the `dplyr::filter()` function by [\\@allison_horst](https://allisonhorst.com/allison-horst).](images/AHorst_filter.png){#fig-filter fig-alt=\"Cartoon showing three fuzzy monsters either selecting or crossing out rows of a data table. If the type of animal in the table is “otter” and the site is “bay”, a monster is drawing a purple rectangle around the row. If those conditions are not met, another monster is putting a line through the column indicating it will be excluded. Stylized text reads “dplyr::filter() - keep rows that satisfy your conditions.”\"}\n:::\n\n## Saving and exporting `R` objects {#sec-ExportingRObjects}\n\nAs a final step, we want to save the `R` object `combined.data` to a local file on our computer so that, when we continue our analyses in a new `R` session, we can immediately start working with the wrangled dataset. We can either save the wrangled dataset as an `R` object (`.rds`) or export it as a DSV file (e.g. `.csv`, see @sec-DSV). The pros and cons of the two solutions are summarised in @tbl-saving.\n\n| DSV files (e.g., `.csv`, `.tsv`, `.tab`) | `R` data files (`.rds`) |\n|:---|:---|\n| ✅ Highly portable (i.e., can be opened in all standard spreadsheet software and text editors). | ❌ Specific to `R` and cannot be opened in standard spreadsheet software or text editors. |\n| ❌ Inefficient for very large datasets. | ✅ Efficient memory usage for more compact data storage and faster loading times in `R`. |\n| ✅ Universal, language-independent format and therefore suitable for long-term archiving. | ❌ No guarantee that older `.rds` files will be compatible with newer versions of `R` and therefore unsuitable for long-term archiving. |\n| ❌ Loss of metadata. | ✅ Preserve `R` data structures (e.g., factor variables remain stored as factors). |\n\n: Pros and cons of saving DSV and `R` data files. {#tbl-saving}\n\nWe will save both a `.csv` and an `.rds` version of the wrangled data but in the following chapters, we will use the `.rds` file.\n\nWe will save both files to a subfolder of our project \"data\" folder called \"processed\". If we try to save the file to this subfolder before it has been created at this location we get an error message.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(combined.data, file = here(\"data\", \"processed\", \"combined_L1_L2_data.rds\"))\n```\n:::\n\n\n```         \nError in gzfile(file, mode) : cannot open the connection\n```\n\nWe first need to create the \"processed\" subfolder before we can save to this location! There are two ways of doing this:\n\n1.  Either in the Files pane of *RStudio* or in a File Navigator/Explorer window, navigate to the \"data\" folder and, from there, click on the \"Create a new folder\" icon to create a new subfolder called \"processed\".\n\n2.  Alternatively, we can use the `dir.create()` function to create the subfolder from `R` itself. If the folder already exists at this location, we will get a warning.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndir.create(file.path(here(\"data\", \"processed\")))\n```\n:::\n\n\nNow that the subfolder exists, we can save `combined.data` as an `.rds` file. We will work with this file in the following chapters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(combined.data, file = here(\"data\", \"processed\", \"combined_L1_L2_data.rds\"))\n```\n:::\n\n\nIf you want to share your wrangled dataset with a colleague who does not (yet? 😉) use `R`, you can use the tidyverse function `write_csv()`.[^9_datawrangling-5] Your colleague will be able to open this file in any standard spreadsheet programme or text editor (but do warn them about the dangers of opening `.csv` file in spreadsheets, see @sec-ExcelWarning!).\n\n[^9_datawrangling-5]: As usual, there is a base `R` alternative: `write.csv()` will work just as well but, for larger datasets, it is considerably slower than `write_csv()`. For finer differences, check out the functions' respective help files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(combined.data, file = here(\"data\", \"processed\", \"combined_L1_L2_data.csv\"))\n```\n:::\n\n\n## Check your progress 🌟 {.unnumbered}\n\nYou have successfully completed [`<span id=\"checkdown_final_score\">0</span>`{=html} out of 5 questions]{style=\"color:green;\"} in this chapter.\n\nThat was a lot of data wrangling, but we are now ready to proceed with some comparative analyses of L1 and L2 English speakers' language skills!\n\nAre you confident that you can...?\n\n-   [ ] Define tidy data (@sec-tidyverse)\n-   [ ] Check the sanity of a dataset (@sec-Sanity)\n-   [ ] Convert character vectors representing categorical data to factors (@sec-Factors)\n-   [ ] Add and replace columns in a table (@sec-mutate)\n-   [ ] Transform several columns at once (@sec-across)\n-   [ ] Use {stringr} functions to manipulate text values (@sec-stringR)\n-   [ ] Interpret `R` package cheatsheets\n-   [ ] Gain insights from the help file of `R` functions\n-   [ ] Use tidyverse functions to pre-process data in an readable and reproducible way (@sec-Preprocessing) and (@sec-filter)\n-   [ ] Save `R` objects as `.rds` and `.csv` files on your computer (@sec-ExportingRObjects)\n\nThe [following chapter](@sec-DataViz) stays in the tidyverse as we will learn how to use the popular tidyverse package {ggplot2} to visualise the pre-processed data from @DabrowskaExperienceAptitudeIndividual2019.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}